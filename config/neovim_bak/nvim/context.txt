// File: init.lua
require("solinaire")


// File: lua/solinaire/remap.lua
local utils = require("solinaire.utils")

vim.g.mapleader = ' '
vim.g.maplocalleader = ' '

---------------------
-- General Keymaps
---------------------

utils.keymap("i", "<C-j>", "<Down>", { desc = "Insert Mode Down" })
utils.keymap("i", "<C-k>", "<Up>", { desc = "Insert Mode Up" })
utils.keymap("i", "<C-h>", "<Left>", { desc = "Insert Mode Left" })
utils.keymap("i", "<C-l>", "<Right>", { desc = "Insert Mode Right" })

-- remap write and quit to capitals
vim.cmd([[
command! W write
command! Q quit
command! Wq write | quit
command! WQ write | quit
noremap q <Nop>
noremap Q q
]])

utils.keymap("n", "<leader>ch", ":nohl<CR>", { desc = "Clear Search Highlights" })

utils.keymap("n", "x", '"_x', { desc = "Delete Char without Copy" })

-- window management
utils.keymap("n", "<leader>sv", "<C-w>v", { desc = "Split Vertical" })
utils.keymap("n", "<leader>sh", "<C-w>s", { desc = "Split Horizontal" })

-- buffer navigation
utils.keymap("n", "<leader>p", "<cmd>BufferLineCyclePrev<cr>", { desc = "Prev Buffer" })
utils.keymap("n", "<leader>n", "<cmd>BufferLineCycleNext<cr>", { desc = "Next Buffer" })

-- disable arrow navigation in normal mode
utils.keymap("n", "<Up>", "<Nop>")
utils.keymap("n", "<Down>", "<Nop>")
utils.keymap("n", "<Left>", "<Nop>")
utils.keymap("n", "<Right>", "<Nop>")


// File: lua/solinaire/opts.lua
-- Set highlight on search
vim.o.hlsearch = false

-- Make line numbers default
vim.wo.number = true

-- Enable mouse mode
vim.o.mouse = 'a'

-- Sync clipboard between OS and Neovim.
--  Remove this option if you want your OS clipboard to remain independent.
--  See `:help 'clipboard'`
vim.o.clipboard = 'unnamedplus'

-- Enable break indent
vim.o.breakindent = true

vim.o.tabstop = 4       -- 4 spaces for tabs (prettier default)
vim.o.shiftwidth = 4    -- 4 spaces for indent width
vim.o.expandtab = true  -- expand tab to spaces
vim.o.autoindent = true -- copy indent from current line when starting new one

-- Save undo history
vim.o.undofile = true

vim.o.relativenumber = true

-- Case-insensitive searching UNLESS \C or capital in search
vim.o.ignorecase = true
vim.o.smartcase = true

-- Keep signcolumn on by default
vim.wo.signcolumn = 'yes'

-- Decrease update time
vim.o.updatetime = 250
vim.o.timeoutlen = 300

-- Set completeopt to have a better completion experience
vim.o.completeopt = 'menuone,noselect'

vim.o.termguicolors = true

-- backspace
vim.o.backspace = "indent,eol,start" -- allow backspace on indent, end of line or insert mode start position

-- split windows
vim.o.splitright = true       -- split vertical window to the right
vim.o.splitbelow = true       -- split horizontal window to the bottom
--
vim.opt.iskeyword:append("-") -- consider string-string as whole word


// File: lua/solinaire/lazy_init.lua
local lazypath = vim.fn.stdpath 'data' .. '/lazy/lazy.nvim'
if not vim.loop.fs_stat(lazypath) then
    vim.fn.system {
        'git',
        'clone',
        '--filter=blob:none',
        'https://github.com/folke/lazy.nvim.git',
        '--branch=stable', -- latest stable release
        lazypath,
    }
end
vim.opt.rtp:prepend(lazypath)

require('lazy').setup({
    spec = 'solinaire.lazy',
    change_detection = {
        notify = true,
    },
})


// File: lua/solinaire/init.lua
require("solinaire.opts")
require("solinaire.remap")
require("solinaire.lazy_init")

local utils = require("solinaire.utils")
local augroup = vim.api.nvim_create_augroup
local autocmd = vim.api.nvim_create_autocmd

local SolinaireGroup = augroup("Solinaire", { clear = true })

-- Remove trailing whitespace on save
autocmd("BufWritePre", {
    group = SolinaireGroup,
    pattern = "*",
    command = [[%s/\s\+$//e]],
})

-- Attach LSP Keymaps
autocmd("LspAttach", {
    group = SolinaireGroup,
    callback = function(args)
        local bufnr = args.buf
        local opts = function(desc)
            return { buffer = bufnr, desc = desc }
        end

        utils.keymap("n", "<leader>gd", function() vim.lsp.buf.definition() end, opts("[G]o to [D]efinition"))
        utils.keymap("n", "K", function() vim.lsp.buf.hover() end, opts("Hover Documentation"))
        utils.keymap("n", "<leader>sb", function() vim.lsp.buf.workspace_symbol() end, opts("Workspace [S]ym[b]ol"))
        utils.keymap("n", "<leader>fr", function() vim.lsp.buf.references() end, opts("[F]ind [R]eferences"))
        utils.keymap("n", "<leader>rn", function() vim.lsp.buf.rename() end, opts("[R]e[n]ame"))
        utils.keymap("i", "<C-h>", function() vim.lsp.buf.signature_help() end, opts("Signature [H]elp"))
        utils.keymap("n", "<C-j>", function() vim.diagnostic.goto_next() end, opts("Next Diagnostic"))
        utils.keymap("n", "<C-k>", function() vim.diagnostic.goto_prev() end, opts("Previous Diagnostic"))
    end,
})


// File: lua/solinaire/utils.lua
local M = {}

-- Function to set key mappings
function M.keymap(mode, lhs, rhs, opts)
    local options = { noremap = true, silent = true }
    if opts then
        options = vim.tbl_extend('force', options, opts)
    end
    vim.keymap.set(mode, lhs, rhs, options)
end

function M.get_augroup(client)
    if not M.augroups[client.id] then
        local group_name = 'lsp-autoformat-' .. client.name
        local id = vim.api.nvim_create_augroup(group_name, { clear = true })
        M.augroups[client.id] = id
    end

    return M.augroups[client.id]
end

return M


// File: lua/solinaire/custom/autoformat.lua
return {
  'neovim/nvim-lspconfig',
  config = function()
    local format_is_enabled = true
    vim.api.nvim_create_user_command('KickstartFormatToggle', function()
      format_is_enabled = not format_is_enabled
      print('Setting autoformatting to: ' .. tostring(format_is_enabled))
    end, {})

    local _augroups = {}
    local get_augroup = function(client)
      if not _augroups[client.id] then
        local group_name = 'kickstart-lsp-format-' .. client.name
        local id = vim.api.nvim_create_augroup(group_name, { clear = true })
        _augroups[client.id] = id
      end

      return _augroups[client.id]
    end

    vim.api.nvim_create_autocmd('LspAttach', {
      group = vim.api.nvim_create_augroup('kickstart-lsp-attach-format', { clear = true }),

      callback = function(args)
        local client_id = args.data.client_id
        local client = vim.lsp.get_client_by_id(client_id)
        local bufnr = args.buf

        if not client.server_capabilities.documentFormattingProvider then
          return
        end

        -- if client.name == 'tsserver' then
        -- return
        -- end

        vim.api.nvim_create_autocmd('BufWritePre', {
          group = get_augroup(client),
          buffer = bufnr,
          callback = function()
            if not format_is_enabled then
              return
            end

            vim.lsp.buf.format {
              async = false,
              filter = function(c)
                return c.id == client.id
              end,
            }
          end,
        })
      end,
    })
  end,
}


// File: lua/solinaire/custom/debug.lua
return {
  'mfussenegger/nvim-dap',
  dependencies = {
    'rcarriga/nvim-dap-ui',

    'williamboman/mason.nvim',
    'jay-babu/mason-nvim-dap.nvim',

    'leoluz/nvim-dap-go',
  },
  config = function()
    local dap = require 'dap'
    local dapui = require 'dapui'

    require('mason-nvim-dap').setup {
      automatic_setup = true,
      handlers = {},
      ensure_installed = {
        -- Update this to ensure that you have the debuggers for the langs you want
        'delve',
        'kotlin-debug-adapter',
      }
    }

    vim.keymap.set('n', '<F5>', dap.continue, { desc = 'Debug: Start/Continue' })
    vim.keymap.set('n', '<F1>', dap.step_into, { desc = 'Debug: Step Into' })
    vim.keymap.set('n', '<F2>', dap.step_over, { desc = 'Debug: Step Over' })
    vim.keymap.set('n', '<F3>', dap.step_out, { desc = 'Debug: Step Out' })
    vim.keymap.set('n', '<leader>tb', dap.toggle_breakpoint, { desc = 'Debug: Toggle Breakpoint' })
    vim.keymap.set('n', '<leader>TB', function()
      dap.set_breakpoint(vim.fn.input 'Breakpoint condition: ')
    end, { desc = 'Debug: Set Breakpoint' })


    dapui.setup {
      icons = { expanded = '▾', collapsed = '▸', current_frame = '*' },
      controls = {
        icons = {
          pause = '⏸',
          play = '▶',
          step_into = '⏎',
          step_over = '⏭',
          step_out = '⏮',
          step_back = 'b',
          run_last = '▶▶',
          terminate = '⏹',
          disconnect = '⏏',
        },
      },
    }

    -- Toggle to see last session result. Without this, you can't see session output in case of unhandled exception.
    vim.keymap.set('n', '<F7>', dapui.toggle, { desc = 'Debug: See last session result.' })

    dap.listeners.after.event_initialized['dapui_config'] = dapui.open
    dap.listeners.before.event_terminated['dapui_config'] = dapui.close
    dap.listeners.before.event_exited['dapui_config'] = dapui.close

    -- Install golang specific config
    require('dap-go').setup()
  end,
}


// File: lua/solinaire/lazy/trouble.lua
return {
    "folke/trouble.nvim",
    opts = {}, -- for default options, refer to the configuration section for custom setup.
    cmd = "Trouble",
    keys = {
        {
            "<leader>ts",
            "<cmd>Trouble symbols toggle pinned=true win.relative=win win.position=right<cr>",
            desc = "Symbols",
        },
        {
            "<leader>tr",
            "<cmd>Trouble diagnostics toggle filter.buf=0 focus=true<cr>",
            desc = "Buffer Diagnostics (Trouble)",
        },
    },
}


// File: lua/solinaire/lazy/blameline.lua
return {
    "braxtons12/blame_line.nvim",
    config = function()
        require("blame_line").setup({
            show_in_visual = false,
            show_in_insert = false,
            delay = 1000,
        })
    end
}


// File: lua/solinaire/lazy/vimoptions.lua
return {
    'anuvyklack/hydra.nvim',
    config = function()
        local Hydra = require("hydra")

        local hint = [[
  ^ ^        Options
  ^
  _v_ %{ve} virtual edit
  _i_ %{list} invisible characters
  _s_ %{spell} spell
  _w_ %{wrap} wrap
  _c_ %{cul} cursor line
  _n_ %{nu} number
  _r_ %{rnu} relative number
  ^
       ^^^^                _<Esc>_
]]

        Hydra({
            name = 'Options',
            hint = hint,
            config = {
                color = 'amaranth',
                invoke_on_body = true,
                hint = {
                    border = 'rounded',
                    position = 'middle'
                }
            },
            mode = { 'n', 'x' },
            body = '<leader>o',
            heads = {
                { 'n', function()
                    if vim.o.number == true then
                        vim.o.number = false
                    else
                        vim.o.number = true
                    end
                end, { desc = 'number' } },
                { 'r', function()
                    if vim.o.relativenumber == true then
                        vim.o.relativenumber = false
                    else
                        vim.o.number = true
                        vim.o.relativenumber = true
                    end
                end, { desc = 'relativenumber' } },
                { 'v', function()
                    if vim.o.virtualedit == 'all' then
                        vim.o.virtualedit = 'block'
                    else
                        vim.o.virtualedit = 'all'
                    end
                end, { desc = 'virtualedit' } },
                { 'i', function()
                    if vim.o.list == true then
                        vim.o.list = false
                    else
                        vim.o.list = true
                    end
                end, { desc = 'show invisible' } },
                { 's', function()
                    if vim.o.spell == true then
                        vim.o.spell = false
                    else
                        vim.o.spell = true
                    end
                end, { exit = true, desc = 'spell' } },
                { 'w', function()
                    if vim.o.wrap ~= true then
                        vim.o.wrap = true
                        -- Dealing with word wrap:
                        -- If cursor is inside very long line in the file than wraps
                        -- around several rows on the screen, then 'j' key moves you to
                        -- the next line in the file, but not to the next row on the
                        -- screen under your previous position as in other editors. These
                        -- bindings fixes this.
                        vim.keymap.set('n', 'k', function() return vim.v.count > 0 and 'k' or 'gk' end,
                            { expr = true, desc = 'k or gk' })
                        vim.keymap.set('n', 'j', function() return vim.v.count > 0 and 'j' or 'gj' end,
                            { expr = true, desc = 'j or gj' })
                    else
                        vim.o.wrap = false
                        vim.keymap.del('n', 'k')
                        vim.keymap.del('n', 'j')
                    end
                end, { desc = 'wrap' } },
                { 'c', function()
                    if vim.o.cursorline == true then
                        vim.o.cursorline = false
                    else
                        vim.o.cursorline = true
                    end
                end, { desc = 'cursor line' } },
                { '<Esc>', nil, { exit = true } }
            }
        })
    end
}


// File: lua/solinaire/lazy/treesitter.lua
return {
    "nvim-treesitter/nvim-treesitter",
    build = ":TSUpdate",
    config = function()
        require("nvim-treesitter.configs").setup({
            ensure_installed = {
                "bash",
                "html",
                "javascript",
                "json",
                "lua",
                "luadoc",
                "luap",
                "markdown",
                "markdown_inline",
                "regex",
                "tsx",
                "typescript",
                "yaml",
                "go",
            },

            -- Install parsers synchronously (only applied to `ensure_installed`)
            sync_install = false,

            -- Automatically install missing parsers when entering buffer
            -- Recommendation: set to false if you don"t have `tree-sitter` CLI installed locally
            auto_install = false,

            indent = {
                enable = true
            },

            highlight = {
                -- `false` will disable the whole extension
                enable = true,

                -- Setting this to true will run `:h syntax` and tree-sitter at the same time.
                -- Set this to `true` if you depend on "syntax" being enabled (like for indentation).
                -- Using this option may slow down your editor, and you may see some duplicate highlights.
                -- Instead of true it can also be a list of languages
                additional_vim_regex_highlighting = { "markdown" },
            },
        })

        --local treesitter_parser_config = require("nvim-treesitter.parsers").get_parser_configs()
        --treesitter_parser_config.templ = {
        --    install_info = {
        --        url = "https://github.com/vrischmann/tree-sitter-templ.git",
        --        files = { "src/parser.c", "src/scanner.c" },
        --        branch = "master",
        --    },
        --}
        --
        --vim.treesitter.language.register("templ", "templ")
    end
}


// File: lua/solinaire/lazy/supermaven.lua
return {
    "supermaven-inc/supermaven-nvim",
    config = function()
        require("supermaven-nvim").setup({})
    end,
}


// File: lua/solinaire/lazy/toggleterm.lua
local utils = require("solinaire.utils")

return {
    {
        "akinsho/toggleterm.nvim",
        version = "*",
        config = function()
            local toggleterm = require("toggleterm")
            toggleterm.setup({
                direction = "float",
                auto_open = true,
                float_opts = {
                    border = "curved",
                },
                winbar = {
                    enabled = false,
                    name_formatter = function(term) --  term: Terminal
                        return term.name
                    end
                },
            })

            utils.keymap("n", "<leader>tt", ":ToggleTerm direction=float<cr>", { desc = "Toggle Terminal Vertical" })
            utils.keymap("n", "<leader>th", ":ToggleTerm direction=horizontal<cr>",
                { desc = "Toggle Terminal Horizontal" })
            -- map esc to close exit terminal mode
            vim.cmd([[
            tnoremap <esc> <C-\><C-N>
            ]])
        end,
    },
}


// File: lua/solinaire/lazy/markdown.lua
return {
    {
        'MeanderingProgrammer/render-markdown.nvim',
        dependencies = { 'nvim-treesitter/nvim-treesitter', 'nvim-tree/nvim-web-devicons' },
        ---@module 'render-markdown'
        ---@type render.md.UserConfig
        opts = {},
    }
}


// File: lua/solinaire/lazy/lsp.lua
-- LSP Configuration & Plugins
return {
    "neovim/nvim-lspconfig",
    dependencies = {
        "williamboman/mason.nvim",
        "williamboman/mason-lspconfig.nvim",
        "hrsh7th/cmp-nvim-lsp",
        "hrsh7th/cmp-buffer",
        "hrsh7th/cmp-path",
        "hrsh7th/cmp-cmdline",
        "hrsh7th/nvim-cmp",
        "L3MON4D3/LuaSnip",
        "saadparwaiz1/cmp_luasnip",
        "j-hui/fidget.nvim",
        "stevearc/conform.nvim",
    },


    config = function()
        local cmp = require("cmp")
        local cmp_lsp = require("cmp_nvim_lsp")
        local conform = require("conform")
        local util = require("lspconfig/util")

        local capabilities = vim.tbl_deep_extend(
            "force",
            {},
            vim.lsp.protocol.make_client_capabilities(),
            cmp_lsp.default_capabilities()
        )

        local function get_python_path(workspace)
            -- Use activated virtualenv.
            if vim.env.VIRTUAL_ENV then
                return util.path.join(vim.env.VIRTUAL_ENV, 'bin', 'python')
            end

            -- Find and use virtualenv in workspace directory.
            for _, pattern in ipairs({ '*', '.*' }) do
                local match = vim.fn.glob(util.path.join(workspace, pattern, 'pyvenv.cfg'))
                if match ~= '' then
                    return util.path.join(util.path.dirname(match), 'bin', 'python')
                end
            end

            -- Fallback to system Python.
            return exepath('python3') or exepath('python') or 'python'
        end

        require("fidget").setup()
        require("mason").setup()
        require("mason-lspconfig").setup({
            ensure_installed = {
                "gopls",
                "lua_ls",
                "eslint",
                "pyright",
                "zls",
            },
            handlers = {
                function(server_name)
                    require("lspconfig")[server_name].setup {
                        capabilities = capabilities
                    }
                end,

                ['lua_ls'] = function()
                    local lspconfig = require("lspconfig")
                    lspconfig.lua_ls.setup {
                        capabilities = capabilities,
                        settings = {
                            Lua = {
                                runtime = { version = "Lua 5.1" },
                                diagnostics = {
                                    globals = { "bit", "vim", "it", "describe", "before_each", "after_each" }
                                }
                            },
                        }
                    }
                end,

                ["eslint"] = function()
                    local lspconfig = require("lspconfig")

                    lspconfig.eslint.setup {
                        capabilities = capabilities,
                        root_dir = util.root_pattern(".eslintrc.js", ".eslintrc.cjs", ".eslintrc.json", "package.json", "tsconfig.json"),
                        settings = {
                            workingDirectory = { mode = "auto" },
                        },
                        on_attach = function(_, bufnr)
                            vim.api.nvim_create_autocmd("BufWritePre", {
                                buffer = bufnr,
                                command = "EslintFixAll",
                            })
                        end,
                    }
                end,

                ["zls"] = function()
                    local lspconfig = require("lspconfig")
                    lspconfig.zls.setup {
                        capabilities = capabilities,
                        settings = {
                            zls = {
                                Zls = {
                                    enableAutofix = true,
                                    enable_snippets = true,
                                    enable_ast_check_diagnostics = true,
                                    enable_autofix = true,
                                    enable_import_embedfile_argument_completions = true,
                                    warn_style = true,
                                    enable_semantic_tokens = true,
                                    enable_inlay_hints = true,
                                    inlay_hints_hide_redundant_param_names = true,
                                    inlay_hints_hide_redundant_param_names_last_token = true,
                                    operator_completions = true,
                                    include_at_in_builtins = true,
                                    max_detail_length = 1048576,
                                },
                            },
                        },
                    }
                end,

                ["pyright"] = function()
                    local lspconfig = require("lspconfig")
                    lspconfig.pyright.setup {
                        before_init = function(_, config)
                            config.settings.python.pythonPath = get_python_path(config.root_dir)
                        end,
                        capabilities = capabilities,
                    }
                end,
            },
        })

        -- Conform formatting
        conform.setup()

        vim.api.nvim_create_autocmd("BufWritePre", {
            callback = function(args)
                conform.format {
                    bufnr = args.buf,
                    lsp_fallback = true,
                    quiet = true,
                }
            end,
        })

        local cmp_select = { behavior = cmp.SelectBehavior.Select }

        cmp.setup({
            snippet = {
                expand = function(args)
                    require("luasnip").lsp_expand(args.body)
                end,
            },
            mapping = cmp.mapping.preset.insert({
                ["<C-j>"] = cmp.mapping.select_next_item(),
                ["<C-k>"] = cmp.mapping.select_prev_item(),
                --                ["<C-d>"] = cmp.mapping.scroll_docs(-4),
                --                ["<C-f>"] = cmp.mapping.scroll_docs(4),
                ["<C-Space>"] = cmp.mapping.complete(),
                ["<CR>"] = cmp.mapping.confirm({
                    behavior = cmp.ConfirmBehavior.Replace,
                    select = true,
                }),
            }),
            sources = cmp.config.sources({
                { name = 'nvim_lsp' },
                { name = 'luasnip' },
            }, {
                { name = 'buffer' },
            })
        })

        vim.diagnostic.config({
            float = {
                focusable = false,
                style = "minimal",
                border = "rounded",
                source = "always",
                header = "",
                prefix = "",
            },
        })
    end,
}


// File: lua/solinaire/lazy/multicursor.lua
return {
    {
        "smoka7/multicursors.nvim",
        event = "VeryLazy",
        dependencies = {
            'nvimtools/hydra.nvim',
        },
        opts = {},
        cmd = { 'MCstart', 'MCvisual', 'MCclear', 'MCpattern', 'MCvisualPattern', 'MCunderCursor' },
        keys = {
            {
                mode = { 'v', 'n' },
                '<Leader>m',
                '<cmd>MCstart<cr>',
                desc = 'Create a selection for selected text or word under the cursor',
            },
        },
    }
}


// File: lua/solinaire/lazy/lualine.lua
return {
    {
        'nvim-lualine/lualine.nvim',
        config = function()
            require('lualine').setup({
                options = {
                    icons_enabled = false,
                    theme = 'dracula',
                    component_separators = '|',
                    section_separators = '',
                },
                sections = {
                    lualine_a = { 'mode' },
                    lualine_b = { 'branch' },
                    lualine_c = { {
                        'filename', path = 1,
                    } },
                    lualine_x = { 'encoding', 'fileformat', 'filetype' },
                    lualine_y = { 'progress' },
                    lualine_z = { 'location' },
                },
            })
        end
    },
}


// File: lua/solinaire/lazy/git.lua
return {
    'lewis6991/gitsigns.nvim',
    config = function()
        local gitsigns = require("gitsigns")

        gitsigns.setup {
            signs = {
                add = { text = "+" },
                change = { text = "~" },
                delete = { text = "_" },
                topdelete = { text = "‾" },
                changedelete = { text = "~" },
            }
        }
    end,
}


// File: lua/solinaire/lazy/langs.lua
return {
    "olexsmir/gopher.nvim",
    config = function()
        require("gopher").setup({
            ft = { "go" },
            goimport = 'gopls',
            gofmt = 'gopls',
            max_line_len = 120,
            impl = "impl",
            iferr = "iferr",
        })
    end,
}


// File: lua/solinaire/lazy/misc.lua
return {
    'tpope/vim-sleuth',
    "nvim-neotest/nvim-nio",
    { 'numToStr/Comment.nvim',         opts = {} },
    { 'rmagatti/goto-preview',         opts = {} },
    { "mbbill/undotree" },
    { "christoomey/vim-tmux-navigator" },
}


// File: lua/solinaire/lazy/telescope.lua
local utils = require("solinaire.utils")

return {
    "nvim-telescope/telescope.nvim",
    tag = "0.1.5",
    dependencies = {
        "nvim-lua/plenary.nvim"
    },

    config = function()
        require('telescope').setup {
            defaults = {
                mappings = {
                    i = {
                        ['<C-j>'] = require('telescope.actions').move_selection_next,
                        ['<C-k>'] = require('telescope.actions').move_selection_previous,
                        ['<C-u>'] = false,
                        ['<C-d>'] = false,
                    },
                },
            }
        }

        local builtin = require('telescope.builtin')

        utils.keymap('n', '<leader>fr', builtin.oldfiles, { desc = '[?] Find recently opened files' })
        utils.keymap('n', '<leader>ff', builtin.find_files, { desc = '[F]ind [F]iles' })
        utils.keymap('n', '<leader>fs', builtin.live_grep, { desc = '[F]ind [S]trings' })
        utils.keymap('n', '<leader>fd', builtin.diagnostics, { desc = '[F]ind [D]iagnostics' })
    end
}


// File: lua/solinaire/lazy/colors.lua
function SetMyColors(color)
    color = color or "dracula"
    vim.cmd.colorscheme(color)

    vim.api.nvim_set_hl(0, "Normal", { bg = "none" })
    vim.api.nvim_set_hl(0, "NormalFloat", { bg = "none" })
end

return {
    {
        {
            'xiyaowong/transparent.nvim',

            config = function()
                local transparent = require("transparent")
                transparent.setup {
                    extra_groups = {
                        'help',
                        'terminal',
                        'dashboard',
                    },
                    transparent_background = true,
                    transparent_floating_windows = false,
                }

                transparent.clear_prefix("BufferLine")
                transparent.clear_prefix("NeoTree")
                transparent.clear_prefix("Telescope")
            end
        },
        {
            "Mofiqul/dracula.nvim",
            config = function()
                SetMyColors()
            end
        }
    }
}


// File: lua/solinaire/lazy/actionspreview.lua
local utils = require("solinaire.utils")

return {
    "aznhe21/actions-preview.nvim",
    config = function()
        local preview = require("actions-preview")
        utils.keymap("n", "<leader>ca", preview.code_actions, { desc = "Code Actions" })
    end,
}


// File: lua/solinaire/lazy/bufferline.lua
return {
    {
        'akinsho/bufferline.nvim',
        version = '*',
        dependencies = {
            'nvim-tree/nvim-web-devicons',
        },
        config = function()
            require('bufferline').setup {
                options = {
                    numbers = 'none',
                    offsets = {
                        {
                            filetype = 'NeoTree',
                            text = 'File Explorer',
                            text_align = 'left',
                            padding = 1,
                            color = 'transparent',
                            hl = 'Directory',
                        },
                    },
                },
            }
        end,
    }
}


// File: lua/solinaire/lazy/init.lua
return {
    {
        "nvim-lua/plenary.nvim",
        name = "plenary"
    },
}


// File: lua/solinaire/lazy/direnv.lua
return {
    'direnv/direnv.vim'
}


// File: lua/solinaire/lazy/neotree.lua
local utils = require("solinaire.utils")

return {
    {
        "nvim-neo-tree/neo-tree.nvim",
        branch = "v3.x",
        dependencies = {
            "nvim-lua/plenary.nvim",
            "nvim-tree/nvim-web-devicons",
            "MunifTanjim/nui.nvim",
        },
        config = function()
            require("neo-tree").setup({})
            utils.keymap("n", "<leader>e", ":Neotree toggle<cr>", { desc = "Toggle Explorer" })
        end,
    },
}


// File: lua/solinaire/lazy/ui.lua
return {
    {
        "rcarriga/nvim-notify",
        config = function()
            local notify = require("notify")
            notify.setup({
                background_colour = "#000000",
                icons = {
                    ERROR = "",
                    WARN = "",
                    INFO = "",
                    DEBUG = "",
                    TRACE = "✎",
                },
                render = "minimal",
                stages = "fade",
            })
        end,
    },
    {
        "folke/noice.nvim",
        config = function()
            local noice = require("noice")
            noice.setup({
                lsp = {
                    override = {
                        -- override the default lsp markdown formatter with Noice
                        ["vim.lsp.util.convert_input_to_markdown_lines"] = true,
                        -- override the lsp markdown formatter with Noice
                        ["vim.lsp.util.stylize_markdown"] = true,
                        -- override cmp documentation with Noice (needs the other options to work)
                        ["cmp.entry.get_documentation"] = true,
                    },
                },
                presets = {
                    lsp_doc_border = true,
                }
            })
        end,
    },
    {
        "windwp/nvim-autopairs",
        config = function() require("nvim-autopairs").setup {} end
    },
    "windwp/nvim-ts-autotag",
    { 'folke/which-key.nvim', opts = {} },
    {
        "lukas-reineke/indent-blankline.nvim",
        main = "ibl",
        opts = {}
    },
}


// File: lua/solinaire/lazy/todo_comments.lua
local utils = require("solinaire.utils")

return {
    {
        "folke/todo-comments.nvim",
        dependencies = { "nvim-lua/plenary.nvim" },
        opts = {
            signs = true, -- show icons in the signs column
            colors = {
                error = { "#DC2626" },
                warning = { "#FBBF24" },
                info = { "#2563EB" },
                hint = { "#10B981" },
                default = { "#7C3AED" },
                test = { "#FF00FF" }
            },
        },
        utils.keymap("n", "<leader>fc", ":TodoTelescope<CR>", { desc = "[F]ind [C]omments" })
    }
}


// File: lua/solinaire/lazy/neotest.lua
local utils = require("solinaire.utils")

return {
    {
        "nvim-neotest/neotest",
        dependencies = {
            "nvim-lua/plenary.nvim",
            "antoinemadec/FixCursorHold.nvim",
            "nvim-treesitter/nvim-treesitter",
            "marilari88/neotest-vitest",
        },
        config = function()
            local neotest = require("neotest")
            neotest.setup({
                adapters = {
                    require("neotest-vitest"),
                }
            })

            utils.keymap("n", "<leader>rt", function()
                neotest.run.run()
            end)
        end,
    },
}


